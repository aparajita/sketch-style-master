
var that = this;
function run (key, context) {
  that.context = context;

var exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/plugin.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/commands/rename-styles.js":
/*!***************************************!*\
  !*** ./src/commands/rename-styles.js ***!
  \***************************************/
/*! exports provided: renameTextStyles, renameLayerStyles */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renameTextStyles\", function() { return renameTextStyles; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renameLayerStyles\", function() { return renameLayerStyles; });\n/* harmony import */ var _lib_shared_style_renamer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/shared-style-renamer */ \"./src/lib/shared-style-renamer.js\");\n\n\n\nfunction renameTextStyles(context) {\n  var styles = context.document.documentData().layerTextStyles();\n  var renamer = new _lib_shared_style_renamer__WEBPACK_IMPORTED_MODULE_0__[\"SharedStyleRenamer\"](context, styles, 'text');\n  renamer.run();\n}\nfunction renameLayerStyles(context) {\n  var styles = context.document.documentData().layerStyles();\n  var renamer = new _lib_shared_style_renamer__WEBPACK_IMPORTED_MODULE_0__[\"SharedStyleRenamer\"](context, styles, 'layer');\n  renamer.run();\n}\n\n//# sourceURL=webpack:///./src/commands/rename-styles.js?");

/***/ }),

/***/ "./src/lib/MochaJSDelegate.js":
/*!************************************!*\
  !*** ./src/lib/MochaJSDelegate.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MochaJSDelegate; });\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar MochaJSDelegate = /*#__PURE__*/function () {\n  function MochaJSDelegate(selectorHandlerDict, superclass) {\n    _classCallCheck(this, MochaJSDelegate);\n\n    this.uniqueClassName = 'MochaJSDelegate_DynamicClass_' + NSUUID.UUID().UUIDString();\n    this.delegateClassDesc = MOClassDescription.allocateDescriptionForClassWithName_superclass_(this.uniqueClassName, superclass || NSObject);\n    this.delegateClassDesc.registerClass();\n    this.handlers = {};\n\n    if (_typeof(selectorHandlerDict) === 'object') {\n      var selectors = Object.keys(selectorHandlerDict);\n\n      for (var _i = 0, _selectors = selectors; _i < _selectors.length; _i++) {\n        var selectorString = _selectors[_i];\n        this.setHandlerForSelector(selectorString, selectorHandlerDict[selectorString]);\n      }\n    }\n  }\n\n  _createClass(MochaJSDelegate, [{\n    key: \"setHandlerForSelector\",\n    value: function setHandlerForSelector(selectorString, func) {\n      var handlerHasBeenSet = (selectorString in this.handlers);\n      this.handlers[selectorString] = func;\n      /*\n        For some reason, Mocha acts weird about arguments: https://github.com/logancollins/Mocha/issues/28\n        We have to basically create a dynamic handler with a likewise dynamic number of predefined arguments.\n      */\n\n      if (!handlerHasBeenSet) {\n        var args = [];\n        var regex = /:/g;\n\n        while (regex.exec(selectorString)) {\n          args.push('arg' + args.length);\n        } // JavascriptCore tends to die a horrible death if an uncaught exception occurs in an action method\n\n\n        var body = \"{\\n        try {\\n          return func.apply(this, arguments)\\n        }\\n        catch(ex) {\\n          log(ex)\\n        }\\n      }\";\n        var code = NSString.stringWithFormat('(function (%@) %@)', args.join(', '), body);\n        var dynamicFunction = eval(String(code));\n        var selector = NSSelectorFromString(selectorString);\n        this.delegateClassDesc.addInstanceMethodWithSelector_function_(selector, dynamicFunction);\n      }\n    }\n  }, {\n    key: \"removeHandlerForSelector\",\n    value: function removeHandlerForSelector(selectorString) {\n      delete this.handlers[selectorString];\n    }\n  }, {\n    key: \"getHandlerForSelector\",\n    value: function getHandlerForSelector(selectorString) {\n      return this.handlers[selectorString];\n    }\n  }, {\n    key: \"getAllHandlers\",\n    value: function getAllHandlers() {\n      return this.handlers;\n    }\n  }, {\n    key: \"getClass\",\n    value: function getClass() {\n      return NSClassFromString(this.uniqueClassName);\n    }\n  }, {\n    key: \"getClassInstance\",\n    value: function getClassInstance() {\n      return this.getClass()[\"new\"]();\n    }\n  }]);\n\n  return MochaJSDelegate;\n}();\n\n\n\n//# sourceURL=webpack:///./src/lib/MochaJSDelegate.js?");

/***/ }),

/***/ "./src/lib/shared-style-renamer.js":
/*!*****************************************!*\
  !*** ./src/lib/shared-style-renamer.js ***!
  \*****************************************/
/*! exports provided: SharedStyleRenamer, renameTextStyles, renameLayerStyles */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SharedStyleRenamer\", function() { return SharedStyleRenamer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renameTextStyles\", function() { return renameTextStyles; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renameLayerStyles\", function() { return renameLayerStyles; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/lib/utils.js\");\n/* harmony import */ var _sketch_nibui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sketch-nibui */ \"./src/lib/sketch-nibui.js\");\n/* harmony import */ var sketch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! sketch */ \"sketch\");\n/* harmony import */ var sketch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(sketch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _nib_RenameStyles_xib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../nib/RenameStyles.xib */ \"./src/nib/RenameStyles.xib\");\n/* harmony import */ var _nib_RenameStyles_m__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../nib/RenameStyles.m */ \"./src/nib/RenameStyles.m\");\n/* harmony import */ var _manifest_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../manifest.json */ \"./src/manifest.json\");\nvar _manifest_json__WEBPACK_IMPORTED_MODULE_5___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../manifest.json */ \"./src/manifest.json\", 1);\n/*\n  Handler for 'Rename Text Styles' command.\n*/\n // Code being used\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n // webpack build dependencies\n\n\n\n\nvar PREVIEW_COLUMN_COUNT = 2;\nvar PREVIEW_CELL_SPACING = NSMakeSize(16, 2);\nvar PREVIEW_VISIBLE_ROWS = 27;\nvar FIND_FIELD_TAG = 1;\nvar REPLACE_FIELD_TAG = 2;\n\nfunction capitalize(text) {\n  return text.charAt(0).toUpperCase() + text.slice(1);\n}\n\nvar SharedStyleRenamer = /*#__PURE__*/function () {\n  function SharedStyleRenamer(context, styles, layerType) {\n    _classCallCheck(this, SharedStyleRenamer);\n\n    this.context = context;\n    this.sketch = sketch__WEBPACK_IMPORTED_MODULE_2___default.a;\n    this.styles = styles;\n    this.styleInfo = [];\n    this.renamedStyles = [];\n    this.find = '';\n    this.replace = '';\n    this.cellFontRegular = NSFont.systemFontOfSize(NSFont.systemFontSize());\n    this.cellFontBold = NSFont.boldSystemFontOfSize(NSFont.systemFontSize());\n    this.layerType = layerType;\n    this.dialogTitle = \"Rename \".concat(capitalize(layerType), \" Styles\");\n    this.ivars = {\n      styles: styles,\n      renameCount: 0,\n      findPattern: '',\n      ignoreCase: false,\n      useRegex: false,\n      replacePattern: '',\n      showMatchingStyles: false,\n      autoScroll: true,\n      findColor: NSColor.textColor()\n    };\n  }\n\n  _createClass(SharedStyleRenamer, [{\n    key: \"makeAlert\",\n    value: function makeAlert() {\n      var alert = NSAlert[\"new\"]();\n      alert.setMessageText(this.dialogTitle);\n      var icon = NSImage.alloc().initByReferencingFile(this.context.plugin.urlForResourceNamed('rename-styles@2x.png').path());\n      alert.setIcon(icon);\n      return alert;\n    }\n  }, {\n    key: \"loadNib\",\n    value: function loadNib() {\n      this.nib = new _sketch_nibui__WEBPACK_IMPORTED_MODULE_1__[\"NibUI\"](this.context, 'UIBundle', 'RenameStyles', this, this.ivars);\n      this.nib.outlets.window.setTitle(this.dialogTitle);\n      this.nib.outlets.versionLabel.setStringValue(\"v\".concat(_manifest_json__WEBPACK_IMPORTED_MODULE_5__[\"version\"]));\n    }\n  }, {\n    key: \"windowWillClose\",\n    value: function windowWillClose() {\n      NSApp.stopModal();\n    }\n  }, {\n    key: \"controlTextDidChange\",\n    value: function controlTextDidChange(notification) {\n      var tag = notification.object().tag();\n\n      if (tag == FIND_FIELD_TAG) {\n        this.searchForMatchingStyles();\n      } else if (tag == REPLACE_FIELD_TAG) {\n        this.updateReplacedNames();\n      }\n    }\n  }, {\n    key: \"toggleShowOnlyMatchingStyles\",\n    value: function toggleShowOnlyMatchingStyles() {\n      if (!this.nib.ivars.showMatchingStyles.boolValue()) {\n        this.resetRenamedStyles();\n      }\n\n      this.searchForMatchingStyles();\n    }\n  }, {\n    key: \"toggleFindOption\",\n    value: function toggleFindOption() {\n      this.searchForMatchingStyles();\n    }\n  }, {\n    key: \"toggleAutoscroll\",\n    value: function toggleAutoscroll() {\n      this.scrollToFirstRenamedStyle();\n    }\n  }, {\n    key: \"handleRename\",\n    value: function handleRename() {\n      this.renameStyles();\n      NSApp.stopModal();\n    }\n  }, {\n    key: \"handleApply\",\n    value: function handleApply() {\n      this.applyRename();\n    }\n  }, {\n    key: \"handleCancel\",\n    value: function handleCancel() {\n      NSApp.stopModal();\n    }\n  }, {\n    key: \"applyRename\",\n    value: function applyRename() {\n      this.renameStyles();\n      this.initStyleInfo();\n      this.nib.ivars.findPattern = '';\n      this.nib.ivars.replacePattern = '';\n      this.nib.ivars.showMatchingStyles = false;\n      this.nib.outlets.window.makeFirstResponder(this.nib.outlets.window.initialFirstResponder());\n      this.searchForMatchingStyles();\n    }\n  }, {\n    key: \"scrollToFirstRenamedStyle\",\n    value: function scrollToFirstRenamedStyle() {\n      if (!this.nib.ivars.autoScroll.boolValue()) {\n        return;\n      }\n\n      var insets = this.nib.outlets.scrollView.contentInsets();\n      var point = NSMakePoint(0, 0);\n\n      if (this.renamedStyles.length > 0) {\n        for (var i = 0; i < this.renamedStyles.length; i++) {\n          var info = this.renamedStyles[i];\n\n          if (info.newName.length > 0) {\n            point = this.matrix.cellFrameAtRow_column(i, 0).origin;\n            break;\n          }\n        }\n      } else {\n        point = this.matrix.cellFrameAtRow_column(0, 0).origin;\n      }\n\n      point.y -= insets.top - 1; // Not sure why - 1 is necessary, but it is\n\n      this.matrix.scrollPoint(point);\n      this.nib.outlets.scrollView.reflectScrolledClipView(this.nib.outlets.scrollView.contentView());\n    }\n  }, {\n    key: \"searchForMatchingStyles\",\n    value: function searchForMatchingStyles() {\n      // We always want to replace all occurrences of the find string within\n      // a style name, so we have to transform a plain search into a RegExp with\n      // the 'g' flag, because a plain text replace only replaces the first occurrence.\n      var flags = this.nib.ivars.ignoreCase.boolValue() ? 'gi' : 'g';\n      var regex = !!this.nib.ivars.useRegex.boolValue(); // When the text field's value is empty, the bound value is returning null,\n      // so make sure we have at least an empty string.\n\n      var find = String(this.nib.ivars.findPattern || ''); // RegExp constructor can fail, be sure to catch exceptions!\n\n      try {\n        if (regex) {\n          this.find = new RegExp(find, flags);\n        } else {\n          this.find = new RegExp(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"regExpEscape\"])(find), flags);\n        }\n\n        this.nib.ivars.findColor = NSColor.textColor();\n      } catch (ex) {\n        this.nib.ivars.findColor = NSColor.redColor();\n        find = '';\n        this.find = new RegExp('', flags);\n      }\n\n      this.updateStylesToRename(find.length === 0);\n      this.setMatrixData();\n      this.scrollToFirstRenamedStyle();\n    }\n  }, {\n    key: \"updateReplacedNames\",\n    value: function updateReplacedNames() {\n      this.replace = String(this.nib.ivars.replacePattern || '');\n      this.updateRenamedStyles();\n      this.setMatrixData();\n    }\n  }, {\n    key: \"initStyleInfo\",\n    value: function initStyleInfo() {\n      var styles = this.styles.objects();\n      this.styleInfo = new Array(styles.length);\n\n      for (var i = 0; i < styles.length; i++) {\n        var style = styles[i];\n        this.styleInfo[i] = {\n          style: style,\n          name: style.name()\n        };\n      }\n\n      this.styleInfo.sort(function (a, b) {\n        if (a.name < b.name) {\n          return -1;\n        }\n\n        if (a.name > b.name) {\n          return 1;\n        }\n\n        return 0;\n      });\n      this.nib.ivars.renameCount = 0;\n      this.resetRenamedStyles();\n    }\n  }, {\n    key: \"resetRenamedStyles\",\n    value: function resetRenamedStyles() {\n      this.renamedStyles = new Array(this.styleInfo.length);\n\n      for (var i = 0; i < this.styleInfo.length; i++) {\n        var info = this.styleInfo[i];\n        this.renamedStyles[i] = {\n          style: info.style,\n          oldName: info.name,\n          newName: ''\n        };\n      }\n    }\n  }, {\n    key: \"updateStylesToRename\",\n    value: function updateStylesToRename(empty) {\n      var renamedStyles = [];\n      var renameCount = 0;\n\n      for (var i = 0; i < this.styleInfo.length; i++) {\n        var info = this.styleInfo[i];\n        var found = !empty && this.find.test(info.name);\n        var newName = void 0;\n\n        if (found) {\n          newName = info.name.replace(this.find, this.replace);\n\n          if (newName.length === 0) {\n            newName = '<empty>';\n          } else {\n            renameCount++;\n          }\n\n          if (this.nib.ivars.showMatchingStyles.boolValue()) {\n            renamedStyles.push({\n              style: info.style,\n              oldName: info.name,\n              newName: newName\n            });\n          } else {\n            this.renamedStyles[i].newName = newName;\n          }\n        } else if (!this.nib.ivars.showMatchingStyles.boolValue()) {\n          this.renamedStyles[i].newName = '';\n        }\n      }\n\n      if (this.nib.ivars.showMatchingStyles.boolValue()) {\n        this.renamedStyles = renamedStyles;\n      }\n\n      this.nib.ivars.renameCount = renameCount;\n    }\n  }, {\n    key: \"updateRenamedStyles\",\n    value: function updateRenamedStyles() {\n      var renameCount = 0;\n\n      var _iterator = _createForOfIteratorHelper(this.renamedStyles),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var info = _step.value;\n\n          if (info.newName) {\n            info.newName = info.oldName.replace(this.find, this.replace);\n\n            if (info.newName.length === 0) {\n              info.newName = '<empty>';\n            } else {\n              renameCount++;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.nib.ivars.renameCount = renameCount;\n    }\n  }, {\n    key: \"renameStyles\",\n    value: function renameStyles() {\n      var _iterator2 = _createForOfIteratorHelper(this.renamedStyles),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var info = _step2.value;\n\n          if (info.newName.length > 0) {\n            var copy = info.style.copy();\n            copy.setName(info.newName);\n            info.style.syncPropertiesFromObject(copy);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      this.context.document.reloadInspector();\n    }\n  }, {\n    key: \"alignLabelWithColumn\",\n    value: function alignLabelWithColumn(label, column) {\n      var insets = this.nib.outlets.scrollView.contentInsets();\n      var scrollViewOrigin = this.nib.outlets.scrollView.frame().origin;\n      var cellOrigin = this.matrix.cellFrameAtRow_column(0, column).origin;\n      var labelOrigin = label.frame().origin;\n      labelOrigin.x = scrollViewOrigin.x + insets.left + cellOrigin.x;\n      label.setFrameOrigin(labelOrigin);\n    }\n  }, {\n    key: \"setMatrixData\",\n    value: function setMatrixData() {\n      var maxWidth = 0;\n      this.matrix.renewRows_columns(this.renamedStyles.length, PREVIEW_COLUMN_COUNT);\n      this.matrix.sizeToCells();\n      var cells = this.matrix.cells();\n\n      for (var row = 0; row < this.renamedStyles.length; row++) {\n        var info = this.renamedStyles[row]; // After setting the cell's value, get its width so we can calculate\n        // the maximum width we'll need for cells.\n\n        var index = row * PREVIEW_COLUMN_COUNT;\n        var cell = cells[index];\n        cell.setFont(info.newName.length === 0 ? this.cellFontRegular : this.cellFontBold);\n        cell.setStringValue(info.oldName);\n        this.matrix.drawCellAtRow_column(row, 0);\n        var size = cell.cellSize();\n        maxWidth = Math.max(maxWidth, size.width);\n        cell = cells[index + 1];\n        cell.setFont(this.cellFontRegular);\n        cell.setStringValue(info.newName);\n        this.matrix.drawCellAtRow_column(row, 1);\n        size = cell.cellSize();\n        maxWidth = Math.max(maxWidth, size.width);\n      }\n\n      return NSMakeSize(maxWidth, cells[0].cellSize().height);\n    }\n  }, {\n    key: \"initMatrix\",\n    value: function initMatrix() {\n      var BORDER_STYLE = NSBezelBorder;\n      var scrollViewSize = this.nib.outlets.scrollView.frame().size;\n      var contentSize = NSScrollView.contentSizeForFrameSize_horizontalScrollerClass_verticalScrollerClass_borderType_controlSize_scrollerStyle(scrollViewSize, null, NSScroller, BORDER_STYLE, NSRegularControlSize, NSScrollerStyleOverlay);\n      var insets = this.nib.outlets.scrollView.contentInsets();\n      contentSize.width -= insets.left + insets.right;\n      contentSize.height -= insets.top + insets.bottom; // Start with a default size, we'll fix that later\n\n      var cellSize = NSMakeSize(100, 16);\n      var cellPrototype = NSCell.alloc().initTextCell('');\n      this.matrix = NSMatrix.alloc().initWithFrame_mode_prototype_numberOfRows_numberOfColumns(NSMakeRect(0, 0, cellSize.width * PREVIEW_COLUMN_COUNT, cellSize.height * this.renamedStyles.length), NSListModeMatrix, cellPrototype, this.renamedStyles.length, PREVIEW_COLUMN_COUNT);\n      cellSize = this.setMatrixData(); // Add 25% to the cell width to allow for longer names when renaming\n\n      cellSize.width *= 1.25; // Make sure the cell width is no less than half of the initial scrollview width\n\n      var minWidth = Math.floor(scrollViewSize.width / 2);\n      cellSize.width = Math.max(cellSize.width, minWidth);\n      this.matrix.setCellSize(CGSizeMake(cellSize.width, cellSize.height));\n      this.matrix.setIntercellSpacing(PREVIEW_CELL_SPACING);\n      this.matrix.sizeToCells();\n      this.nib.outlets.scrollView.setDocumentView(this.matrix);\n      this.alignLabelWithColumn(this.nib.outlets.beforeLabel, 0);\n      this.alignLabelWithColumn(this.nib.outlets.afterLabel, 1); // Resize the window to fit the matrix\n\n      var matrixHeight = cellSize.height * PREVIEW_VISIBLE_ROWS;\n      matrixHeight += PREVIEW_CELL_SPACING.height * (PREVIEW_VISIBLE_ROWS - 1);\n      var matrixSize = NSMakeSize(this.matrix.frame().size.width, matrixHeight); // Now adjust the containing view width and column labels to fit the matrix\n\n      var frameSize = NSScrollView.frameSizeForContentSize_horizontalScrollerClass_verticalScrollerClass_borderType_controlSize_scrollerStyle(matrixSize, null, NSScroller, BORDER_STYLE, NSRegularControlSize, NSScrollerStyleOverlay); // Take content insets into account\n\n      frameSize.width += insets.left + insets.right;\n      frameSize.height += insets.top + insets.bottom; // Calculate the difference in the old size vs. new size, apply that to the view frame\n\n      var sizeDiff = NSMakeSize(frameSize.width - scrollViewSize.width, frameSize.height - scrollViewSize.height);\n      var windowFrame = this.nib.outlets.window.frame();\n      windowFrame.size.width += sizeDiff.width;\n      windowFrame.size.height += sizeDiff.height;\n      var minSize = this.nib.outlets.window.minSize();\n      windowFrame.size.width = Math.max(windowFrame.size.width, minSize.width);\n      windowFrame.size.height = Math.max(windowFrame.size.height, minSize.height);\n      this.nib.outlets.window.setFrame_display(windowFrame, true);\n    }\n  }, {\n    key: \"showAlert\",\n    value: function showAlert(message) {\n      var alert = this.makeAlert();\n      alert.setInformativeText(message);\n      alert.runModal();\n    }\n  }, {\n    key: \"showFindDialog\",\n    value: function showFindDialog() {\n      if (this.styles.numberOfSharedStyles() === 0) {\n        var alert = this.makeAlert();\n        alert.setInformativeText(\"This document has no shared \".concat(this.layerType, \" styles.\"));\n        alert.runModal();\n        return 0;\n      }\n\n      this.loadNib();\n      this.initStyleInfo();\n      this.initMatrix();\n      return NSApp.runModalForWindow(this.nib.outlets.window);\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      var response = this.showFindDialog();\n\n      if (response !== 0) {\n        this.nib.outlets.window.orderOut(null);\n      }\n\n      return response;\n    }\n  }]);\n\n  return SharedStyleRenamer;\n}();\nfunction renameTextStyles(context) {\n  var styles = context.document.documentData().layerTextStyles();\n  var renamer = new SharedStyleRenamer(context, styles, 'text');\n  renamer.run();\n}\nfunction renameLayerStyles(context) {\n  var styles = context.document.documentData().layerStyles();\n  var renamer = new SharedStyleRenamer(context, styles, 'layer');\n  renamer.run();\n}\n\n//# sourceURL=webpack:///./src/lib/shared-style-renamer.js?");

/***/ }),

/***/ "./src/lib/sketch-nibui.js":
/*!*********************************!*\
  !*** ./src/lib/sketch-nibui.js ***!
  \*********************************/
/*! exports provided: NibUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NibUI\", function() { return NibUI; });\n/* harmony import */ var _MochaJSDelegate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MochaJSDelegate */ \"./src/lib/MochaJSDelegate.js\");\n/*\n * Copyright 2015 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\nvar NibUI = /*#__PURE__*/function () {\n  function NibUI(context, resourceBundleName, nibName, delegate, ivars) {\n    _classCallCheck(this, NibUI);\n\n    var bundlePath = context.plugin.urlForResourceNamed(resourceBundleName).path();\n    this._bundle = NSBundle.bundleWithPath(bundlePath);\n    this._nibName = nibName;\n    this._delegate = delegate;\n    this.outlets = Object.create(null);\n    this.ivars = Object.create(null);\n    this._delegateProxy = null; // Construct a class that will be the nib's owner\n\n    this._createNibOwner(nibName); // Get the list of outlets and actions as defined in the nib\n\n\n    var connections = this._loadConnections(nibName);\n\n    this._prepareOutletConnections(connections.outlets);\n\n    if (delegate) {\n      this._connectActionsToDelegate(connections.actions, delegate);\n    }\n\n    if (ivars) {\n      this._addIvars(ivars);\n    } // Now that the nib owner class is completely constructed, register it with the ObjC runtime\n\n\n    this._registerNibOwner();\n\n    if (ivars) {\n      this._initIvars(ivars);\n    }\n\n    this._load();\n  } // Create a class name that doesn't exist yet. Note that we can't reuse the same\n  // definition lest Sketch will throw an MOJavaScriptException when binding the UI,\n  // probably due to JavaScript context / plugin lifecycle incompatibility.\n\n\n  _createClass(NibUI, [{\n    key: \"_createNibOwner\",\n    value: function _createNibOwner(nibName) {\n      var className;\n\n      do {\n        className = nibName + NSUUID.UUID().UUIDString();\n      } while (NSClassFromString(className) != null);\n\n      this._cls = MOClassDescription.allocateDescriptionForClassWithName_superclass_(className, NSObject); // We need to add the NSObject protocol so it will be KVC compliant\n\n      var protocol = MOProtocolDescription.descriptionForProtocolWithName('NSObject');\n\n      this._cls.addProtocol(protocol);\n    }\n  }, {\n    key: \"_registerNibOwner\",\n    value: function _registerNibOwner() {\n      this._cls.registerClass();\n\n      this._nibOwner = NSClassFromString(this._cls.name()).alloc().init();\n    } // Create setter methods that will be called when connecting each outlet during nib loading.\n    // The setter methods register the connected view.\n\n  }, {\n    key: \"_prepareOutletConnections\",\n    value: function _prepareOutletConnections(outlets) {\n      var _this = this;\n\n      var _loop = function _loop(i) {\n        var outletName = outlets[i];\n        var selector = \"set\".concat(outletName.charAt(0).toUpperCase()).concat(outletName.substring(1), \":\");\n\n        var setterFunc = function setterFunc(view) {\n          _this.outlets[outletName] = view;\n        };\n\n        _this._cls.addInstanceMethodWithSelector_function(NSSelectorFromString(selector), setterFunc);\n      };\n\n      for (var i = 0; i < outlets.length; i++) {\n        _loop(i);\n      }\n    }\n  }, {\n    key: \"_connectDelegateMethods\",\n    value: function _connectDelegateMethods() {\n      if (!this._delegate) {\n        return;\n      }\n\n      var objectsToConnect = [];\n      var view = null;\n\n      if ('window' in this.outlets) {\n        objectsToConnect.push(this.outlets.window);\n        view = this.outlets.window.contentView();\n      } else if ('view' in this.outlets) {\n        view = this.outlets.view;\n      }\n\n      if (!view) {\n        return;\n      }\n\n      this._checkForTextViewsToConnect(view, objectsToConnect);\n\n      if (objectsToConnect.length) {\n        var delegateProxy = this._getDelegateProxy();\n\n        if (delegateProxy) {\n          var _iterator = _createForOfIteratorHelper(objectsToConnect),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var object = _step.value;\n              object.setDelegate(delegateProxy);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_checkForTextViewsToConnect\",\n    value: function _checkForTextViewsToConnect(view, objectsToConnect) {\n      var children = view.subviews();\n\n      for (var _i = 0, _Array$from = Array.from(children); _i < _Array$from.length; _i++) {\n        var childView = _Array$from[_i];\n\n        if (childView.isKindOfClass(NSTextField) && childView.isEditable() && childView.tag() > 0) {\n          objectsToConnect.push(childView);\n        }\n\n        this._checkForTextViewsToConnect(childView, objectsToConnect);\n      }\n    }\n  }, {\n    key: \"_getDelegateProxy\",\n    value: function _getDelegateProxy() {\n      if (!this._delegateProxy) {\n        var selectors = ['windowWillClose:', 'control:textShouldBeginEditing:', 'controlTextDidBeginEditing:', 'controlTextDidChange:', 'control:textShouldEndEditing:', 'controlTextDidEndEditing:'];\n        var delegateConfig = {};\n\n        for (var _i2 = 0, _selectors = selectors; _i2 < _selectors.length; _i2++) {\n          var selector = _selectors[_i2];\n          var methodName = selector.replace(/(:.)/g, function (match, subpattern) {\n            return subpattern.charAt(1).toUpperCase();\n          }).replace(/:$/, '');\n          var method = this._delegate[methodName];\n\n          if (method) {\n            delegateConfig[selector] = method.bind(this._delegate);\n          }\n        }\n\n        var delegate = new _MochaJSDelegate__WEBPACK_IMPORTED_MODULE_0__[\"default\"](delegateConfig);\n        this._delegateProxy = delegate.getClassInstance();\n      }\n\n      return this._delegateProxy;\n    } // Hook up actions with the delegate\n\n  }, {\n    key: \"_connectActionsToDelegate\",\n    value: function _connectActionsToDelegate(actions, delegate) {\n      var _this2 = this;\n\n      var _iterator2 = _createForOfIteratorHelper(actions),\n          _step2;\n\n      try {\n        var _loop2 = function _loop2() {\n          var action = _step2.value;\n          var funcName = action.slice(0, -1); // Trim ':' from end of action\n\n          var func = delegate[funcName];\n\n          if (typeof func === 'function') {\n            var forwardingFunc = function forwardingFunc(sender) {\n              // javascriptCore tends to die a horrible death if an uncaught exception occurs in an action method\n              try {\n                func.call(delegate, sender);\n              } catch (ex) {\n                log(NSString.stringWithFormat('%@: %@\\nStack:\\n%@', ex.name, ex.message, ex.stack));\n              }\n            };\n\n            _this2._cls.addInstanceMethodWithSelector_function(NSSelectorFromString(action), forwardingFunc);\n          }\n        };\n\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          _loop2();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"_addIvars\",\n    value: function _addIvars(ivars) {\n      var _this3 = this;\n\n      var _loop3 = function _loop3() {\n        var name = _Object$keys[_i3];\n        // Step 1: add an ivar to the nib owner class\n        var value = ivars[name];\n\n        var typeEncoding = _this3.constructor._typeEncodingForValue(value);\n\n        if (!typeEncoding) {\n          log(\"Cannot determine the type encoding for the ivar '\".concat(name, \"', value = \").concat(value));\n          return \"continue\";\n        }\n\n        if (_this3._cls.addInstanceVariableWithName_typeEncoding(name, typeEncoding)) {\n          // Step 2: add a getter/setter to the ivar proxy object\n          Object.defineProperty(_this3.ivars, name, {\n            get: function get() {\n              return _this3.getIvar(name);\n            },\n            set: function set(value) {\n              _this3.setIvar(name, value);\n            }\n          });\n        } else {\n          log('Unable to add ivar: ' + name);\n        }\n      };\n\n      for (var _i3 = 0, _Object$keys = Object.keys(ivars); _i3 < _Object$keys.length; _i3++) {\n        var _ret = _loop3();\n\n        if (_ret === \"continue\") continue;\n      }\n    }\n  }, {\n    key: \"_initIvars\",\n    value: function _initIvars(ivars) {\n      for (var _i4 = 0, _Object$keys2 = Object.keys(ivars); _i4 < _Object$keys2.length; _i4++) {\n        var name = _Object$keys2[_i4];\n        this.setIvar(name, ivars[name]);\n      }\n    }\n  }, {\n    key: \"_loadConnections\",\n    value: function _loadConnections(nibName) {\n      var path = \"\".concat(this._bundle.resourcePath(), \"/\").concat(nibName, \".json\");\n      var json = NSString.stringWithContentsOfFile_encoding_error(path, NSUTF8StringEncoding, null);\n\n      if (json) {\n        return JSON.parse(json);\n      }\n\n      return {\n        outlets: [],\n        actions: []\n      };\n    }\n  }, {\n    key: \"_load\",\n    value: function _load() {\n      var tloPointer = MOPointer.alloc().initWithValue(null);\n\n      if (!this._bundle.loadNibNamed_owner_topLevelObjects(this._nibName, this._nibOwner, tloPointer)) {\n        throw new Error(\"Could not load nib '\".concat(this._nibName, \"'\"));\n      }\n\n      this._connectDelegateMethods();\n    }\n  }, {\n    key: \"getIvar\",\n    value: function getIvar(name) {\n      return this._nibOwner.valueForKey(name);\n    }\n  }, {\n    key: \"setIvar\",\n    value: function setIvar(name, value) {\n      this._nibOwner.setValue_forKey(value, name);\n    }\n  }], [{\n    key: \"_typeEncodingForValue\",\n    value: function _typeEncodingForValue(value) {\n      var valueType = _typeof(value);\n\n      switch (valueType) {\n        case 'string':\n        case 'object':\n          return '@';\n\n        case 'number':\n          return 'd';\n\n        case 'boolean':\n          return 'i';\n\n        default:\n          return null;\n      }\n    }\n  }]);\n\n  return NibUI;\n}();\n\n//# sourceURL=webpack:///./src/lib/sketch-nibui.js?");

/***/ }),

/***/ "./src/lib/utils.js":
/*!**************************!*\
  !*** ./src/lib/utils.js ***!
  \**************************/
/*! exports provided: regExpEscape */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"regExpEscape\", function() { return regExpEscape; });\n/* eslint no-control-regex: 0 */\n\n/**\n  Utility functions\n*/\nfunction regExpEscape(s) {\n  return String(s).replace(/([-()[\\]{}+?*.$^|,:#<!\\\\])/g, '\\\\$1').replace(/\\x08/g, '\\\\x08');\n}\n\n//# sourceURL=webpack:///./src/lib/utils.js?");

/***/ }),

/***/ "./src/manifest.json":
/*!***************************!*\
  !*** ./src/manifest.json ***!
  \***************************/
/*! exports provided: name, version, identifier, description, author, authorEmail, homepage, compatibleVersion, bundleVersion, icon, disableCocoaScriptPreprocessor, scope, appcast, nibProject, nibBundle, commands, menu, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"name\\\":\\\"Style Master\\\",\\\"version\\\":\\\"1.0.4\\\",\\\"identifier\\\":\\\"com.aparajita.style-master\\\",\\\"description\\\":\\\"Shared style renaming.\\\",\\\"author\\\":\\\"Aparajita Fishman\\\",\\\"authorEmail\\\":\\\"aparajita@aparajita.com\\\",\\\"homepage\\\":\\\"https://github.com/aparajita/sketch-style-master\\\",\\\"compatibleVersion\\\":\\\"66.0\\\",\\\"bundleVersion\\\":1,\\\"icon\\\":\\\"icon.png\\\",\\\"disableCocoaScriptPreprocessor\\\":true,\\\"scope\\\":\\\"document\\\",\\\"appcast\\\":\\\"https://raw.githubusercontent.com/aparajita/sketch-style-master/master/appcast.xml\\\",\\\"nibProject\\\":\\\"nib\\\",\\\"nibBundle\\\":\\\"UIBundle\\\",\\\"commands\\\":[{\\\"name\\\":\\\"Rename Text Styles\\\",\\\"script\\\":\\\"plugin.js\\\",\\\"handler\\\":\\\"renameTextStyles\\\",\\\"identifier\\\":\\\"rename-text-styles\\\",\\\"description\\\":\\\"Rename shared text styles\\\",\\\"icon\\\":\\\"rename-styles.png\\\"},{\\\"name\\\":\\\"Rename Layer Styles\\\",\\\"script\\\":\\\"plugin.js\\\",\\\"handler\\\":\\\"renameLayerStyles\\\",\\\"identifier\\\":\\\"rename-layer-styles\\\",\\\"description\\\":\\\"Rename shared layer styles\\\",\\\"icon\\\":\\\"rename-styles.png\\\"}],\\\"menu\\\":{\\\"title\\\":\\\"Style Master\\\",\\\"items\\\":[\\\"rename-text-styles\\\",\\\"rename-layer-styles\\\"]}}\");\n\n//# sourceURL=webpack:///./src/manifest.json?");

/***/ }),

/***/ "./src/nib/RenameStyles.m":
/*!********************************!*\
  !*** ./src/nib/RenameStyles.m ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"d99eeff1-6c28-4002-a77e-9d31e38a47f0\");\n\n//# sourceURL=webpack:///./src/nib/RenameStyles.m?");

/***/ }),

/***/ "./src/nib/RenameStyles.xib":
/*!**********************************!*\
  !*** ./src/nib/RenameStyles.xib ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"dc271653-9187-48bd-b54c-47847888d759\");\n\n//# sourceURL=webpack:///./src/nib/RenameStyles.xib?");

/***/ }),

/***/ "./src/plugin.js":
/*!***********************!*\
  !*** ./src/plugin.js ***!
  \***********************/
/*! exports provided: renameTextStyles, renameLayerStyles */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _manifest_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./manifest.json */ \"./src/manifest.json\");\nvar _manifest_json__WEBPACK_IMPORTED_MODULE_0___namespace = /*#__PURE__*/__webpack_require__.t(/*! ./manifest.json */ \"./src/manifest.json\", 1);\n/* harmony import */ var _commands_rename_styles_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./commands/rename-styles.js */ \"./src/commands/rename-styles.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"renameTextStyles\", function() { return _commands_rename_styles_js__WEBPACK_IMPORTED_MODULE_1__[\"renameTextStyles\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"renameLayerStyles\", function() { return _commands_rename_styles_js__WEBPACK_IMPORTED_MODULE_1__[\"renameLayerStyles\"]; });\n\n // webpack build dependency\n\n // Export * from all of the commands\n\n\n\n//# sourceURL=webpack:///./src/plugin.js?");

/***/ }),

/***/ "sketch":
/*!*************************!*\
  !*** external "sketch" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"sketch\");\n\n//# sourceURL=webpack:///external_%22sketch%22?");

/***/ })

/******/ });
  if (key === 'default' && typeof exports === 'function') {
    exports(context);
  } else {
    exports[key](context);
  }
}

that['onRun'] = run.bind(this, 'default');
that['renameTextStyles'] = run.bind(this, 'renameTextStyles');
that['renameLayerStyles'] = run.bind(this, 'renameLayerStyles');
